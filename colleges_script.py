# -*- coding: utf-8 -*-
"""cleanNotebook

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18dEBhi6aSPoHOu8Y1YVJCTM_-dclJfq0
"""
from operator import itemgetter
import math
import os
import random

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

"""# Methods"""


def class_size_ranker(sample_data, desired_class_size):
    def size_logifier(class_size):
        return math.log(class_size*4, 10)
    sd2 = sample_data.copy()
    sd2['log_class_size'] = sd2["Enrolled Full Time Total"].apply(
        size_logifier)
    sd2['lg_diff'] = abs(sd2.log_class_size -
                         size_logifier(desired_class_size))
    sd2['Class Rank'] = sd2['lg_diff'].rank(method='min', ascending=True)
    return sd2


def region_ranker(sample_data, preferred_regions):
    """
    "region1": "preferred", 
    "region2": "//"
    """
    sd2 = sample_data.copy()
    b = {"Preferred": 0, "Neutral": 1, "Not_Preferred": 3}

    # TODO: Upgrade to rank regions instead of binary preference

    sd2['Region Ranks'] = sd2.Region.apply(
        lambda x:  1+(b[preferred_regions[x]]*len(sample_data)/3))
    return sd2


def ppp_ranker(sample_data, ppref):
    sd2 = sample_data.copy()
    sd2['PPP Ranks'] = sd2.Ownership.apply(
        lambda x: 1 if x == ppref else len(sd2))
    return sd2


def ur_ranker(sample_data, urpref):
    b = {'City: Large': 11,
         'City: Midsize': 10,
         'City: Small': 9,
         'Rural: Distant': 1,
         'Rural: Fringe': 2,
         'Rural: Remote': 0,
         'Suburb: Large': 8,
         'Suburb: Midsize': 7,
         'Suburb: Small': 6,
         'Town: Distant': 4,
         'Town: Fringe': 5,
         'Town: Remote': 3}

    ur_metric = {i: 1 + i*len(sample_data)/len(b) for i in range(len(b))}
    sd2 = sample_data.copy()
    sd2['UR Score'] = sd2['Area Type'].apply(lambda x: b[x])
    sd2['UR Rank'] = abs(
        sd2['UR Score'] - urpref).apply(lambda x: ur_metric[x])
    return sd2


def sf_ranker(sample_data):
    sd2 = sample_data.copy()
    sd2['S_F Rank'] = sd2['Student-to-Faculty Ratio'].rank(
        method='min', ascending=True)
    return sd2


def SG_ranker(sample_data, satVR, satMT, GPA):
    sd2 = sample_data.copy()
    sd2['VR_Rank'] = abs(sd2['Average SATVR'] -
                         satVR).rank(method='min', ascending=True)
    sd2['MT_Rank'] = abs(sd2['Average SATMT'] -
                         satMT).rank(method='min', ascending=True)
    sd2['GPA_Rank'] = abs(sd2['Average GPA'] -
                          GPA).rank(method='min', ascending=True)
    sd2['GPA_Rank'].fillna(.5*sd2.VR_Rank + .5*sd2.MT_Rank, inplace=True)
    sd2['VR_Rank'].fillna(sd2.GPA_Rank, inplace=True)
    sd2['MT_Rank'].fillna(sd2.GPA_Rank, inplace=True)
    return sd2


def rankifier(sd, desired_class_size, preferred_regions, ppref, urpref, satVR, satMT, GPA):
    sd2 = sd.copy()
    sd2 = class_size_ranker(sd2, desired_class_size)
    sd2 = region_ranker(sd2, preferred_regions)
    sd2 = ppp_ranker(sd2, ppref)
    sd2 = ur_ranker(sd2, urpref)
    sd2 = sf_ranker(sd2)
    sd2 = SG_ranker(sd2, satVR, satMT, GPA)
    return sd2


def final_ranker(fvd, class_size, ur_pref, sat_vr, sat_mt, gpa, region_dic):
    rankedData = rankifier(fvd, class_size, region_dic,
                           'Private not-for-profit independent', ur_pref, sat_vr, sat_mt, gpa)
    newRankedData = rankedData.drop(['Area Type', 'Region', 'Ownership',
                                     'Student-to-Faculty Ratio', 'Enrolled Full Time Total', 'Average GPA',
                                     'Average SATVR', 'Average SATMT', 'log_class_size', 'lg_diff', 'UR Score'], axis=1)
    fdr = newRankedData.set_index('College Name').drop('Unnamed: 0', axis=1)
    fdr['Rank Sum'] = fdr.drop("Rankings", axis=1).iloc[:, ].sum(axis=1)
    return fdr["Rank Sum"].sort_values()


def tier_ranker(fvd, user_preferences):
    class_size, ur_pref, sat_vr, sat_mt, gpa, region_dic = itemgetter(
        'class_size', 'ur_pref', 'sat_vr', 'sat_mt', 'gpa', 'region_dic')(user_preferences)

    reach = final_ranker(fvd, class_size, ur_pref, min(800, sat_vr+fvd['Average SATVR'].std()), min(
        800, sat_mt+fvd['Average SATMT'].std()), min(4, gpa+fvd['Average GPA'].std()), region_dic)
    midtier = final_ranker(fvd, class_size, ur_pref,
                           sat_vr, sat_mt, gpa, region_dic)
    safety = final_ranker(fvd, class_size, ur_pref, max(0, sat_vr-fvd['Average SATVR'].std()), max(
        0, sat_mt-fvd['Average SATMT'].std()), max(0, gpa-fvd['Average GPA'].std()), region_dic)

    fList = []

    reachList = list(dict(reach[:5]).keys())
    fList.extend(reachList)

    midList = list(dict(midtier).keys())
    fList.extend([i for i in midList if i not in reachList][:5])

    safeList = list(dict(safety).keys())
    fList.extend([i for i in safeList if i not in fList][:5])

    return fList


def get_colleges(user_preferences):
    fvd = pd.read_csv("./FVD.csv")
    return tier_ranker(fvd, user_preferences)
